// Generated by using Rcpp::compileAttributes() -> do not edit by hand
// Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#include "../inst/include/simcdm.h"
#include <RcppArmadillo.h>
#include <Rcpp.h>
#include <string>
#include <set>

using namespace Rcpp;

// sim_dina_class
arma::mat sim_dina_class(unsigned int N, unsigned int J, const arma::vec& CLASS, const arma::mat& ETA, const arma::vec& gs, const arma::vec& ss);
static SEXP _simcdm_sim_dina_class_try(SEXP NSEXP, SEXP JSEXP, SEXP CLASSSEXP, SEXP ETASEXP, SEXP gsSEXP, SEXP ssSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< unsigned int >::type N(NSEXP);
    Rcpp::traits::input_parameter< unsigned int >::type J(JSEXP);
    Rcpp::traits::input_parameter< const arma::vec& >::type CLASS(CLASSSEXP);
    Rcpp::traits::input_parameter< const arma::mat& >::type ETA(ETASEXP);
    Rcpp::traits::input_parameter< const arma::vec& >::type gs(gsSEXP);
    Rcpp::traits::input_parameter< const arma::vec& >::type ss(ssSEXP);
    rcpp_result_gen = Rcpp::wrap(sim_dina_class(N, J, CLASS, ETA, gs, ss));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _simcdm_sim_dina_class(SEXP NSEXP, SEXP JSEXP, SEXP CLASSSEXP, SEXP ETASEXP, SEXP gsSEXP, SEXP ssSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_simcdm_sim_dina_class_try(NSEXP, JSEXP, CLASSSEXP, ETASEXP, gsSEXP, ssSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// sim_dina_attributes
arma::mat sim_dina_attributes(const arma::mat& alphas, const arma::mat& Q);
static SEXP _simcdm_sim_dina_attributes_try(SEXP alphasSEXP, SEXP QSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const arma::mat& >::type alphas(alphasSEXP);
    Rcpp::traits::input_parameter< const arma::mat& >::type Q(QSEXP);
    rcpp_result_gen = Rcpp::wrap(sim_dina_attributes(alphas, Q));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _simcdm_sim_dina_attributes(SEXP alphasSEXP, SEXP QSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_simcdm_sim_dina_attributes_try(alphasSEXP, QSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// sim_dina
arma::mat sim_dina(const arma::mat& alphas, const arma::mat& Q, const arma::vec& ss, const arma::vec& gs);
static SEXP _simcdm_sim_dina_try(SEXP alphasSEXP, SEXP QSEXP, SEXP ssSEXP, SEXP gsSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const arma::mat& >::type alphas(alphasSEXP);
    Rcpp::traits::input_parameter< const arma::mat& >::type Q(QSEXP);
    Rcpp::traits::input_parameter< const arma::vec& >::type ss(ssSEXP);
    Rcpp::traits::input_parameter< const arma::vec& >::type gs(gsSEXP);
    rcpp_result_gen = Rcpp::wrap(sim_dina(alphas, Q, ss, gs));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _simcdm_sim_dina(SEXP alphasSEXP, SEXP QSEXP, SEXP ssSEXP, SEXP gsSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_simcdm_sim_dina_try(alphasSEXP, QSEXP, ssSEXP, gsSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// sim_rrum_main
arma::mat sim_rrum_main(const arma::mat& Q, const arma::mat& rstar, const arma::vec& pistar, const arma::mat& alpha);
static SEXP _simcdm_sim_rrum_main_try(SEXP QSEXP, SEXP rstarSEXP, SEXP pistarSEXP, SEXP alphaSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const arma::mat& >::type Q(QSEXP);
    Rcpp::traits::input_parameter< const arma::mat& >::type rstar(rstarSEXP);
    Rcpp::traits::input_parameter< const arma::vec& >::type pistar(pistarSEXP);
    Rcpp::traits::input_parameter< const arma::mat& >::type alpha(alphaSEXP);
    rcpp_result_gen = Rcpp::wrap(sim_rrum_main(Q, rstar, pistar, alpha));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _simcdm_sim_rrum_main(SEXP QSEXP, SEXP rstarSEXP, SEXP pistarSEXP, SEXP alphaSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_simcdm_sim_rrum_main_try(QSEXP, rstarSEXP, pistarSEXP, alphaSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// sim_rrum
arma::mat sim_rrum(const arma::mat& Q, const arma::mat& rstar, const arma::vec& pistar, const arma::mat& alpha);
static SEXP _simcdm_sim_rrum_try(SEXP QSEXP, SEXP rstarSEXP, SEXP pistarSEXP, SEXP alphaSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const arma::mat& >::type Q(QSEXP);
    Rcpp::traits::input_parameter< const arma::mat& >::type rstar(rstarSEXP);
    Rcpp::traits::input_parameter< const arma::vec& >::type pistar(pistarSEXP);
    Rcpp::traits::input_parameter< const arma::mat& >::type alpha(alphaSEXP);
    rcpp_result_gen = Rcpp::wrap(sim_rrum(Q, rstar, pistar, alpha));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _simcdm_sim_rrum(SEXP QSEXP, SEXP rstarSEXP, SEXP pistarSEXP, SEXP alphaSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_simcdm_sim_rrum_try(QSEXP, rstarSEXP, pistarSEXP, alphaSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// bijectionvector
arma::vec bijectionvector(unsigned int K);
static SEXP _simcdm_bijectionvector_try(SEXP KSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< unsigned int >::type K(KSEXP);
    rcpp_result_gen = Rcpp::wrap(bijectionvector(K));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _simcdm_bijectionvector(SEXP KSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_simcdm_bijectionvector_try(KSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// inv_bijectionvector
arma::vec inv_bijectionvector(unsigned int K, double CL);
static SEXP _simcdm_inv_bijectionvector_try(SEXP KSEXP, SEXP CLSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< unsigned int >::type K(KSEXP);
    Rcpp::traits::input_parameter< double >::type CL(CLSEXP);
    rcpp_result_gen = Rcpp::wrap(inv_bijectionvector(K, CL));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _simcdm_inv_bijectionvector(SEXP KSEXP, SEXP CLSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_simcdm_inv_bijectionvector_try(KSEXP, CLSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// sim_q_matrix
arma::mat sim_q_matrix(unsigned int J, unsigned int K);
static SEXP _simcdm_sim_q_matrix_try(SEXP JSEXP, SEXP KSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< unsigned int >::type J(JSEXP);
    Rcpp::traits::input_parameter< unsigned int >::type K(KSEXP);
    rcpp_result_gen = Rcpp::wrap(sim_q_matrix(J, K));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _simcdm_sim_q_matrix(SEXP JSEXP, SEXP KSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_simcdm_sim_q_matrix_try(JSEXP, KSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// eta_matrix
arma::mat eta_matrix(unsigned int K, unsigned int J, const arma::mat& Q);
static SEXP _simcdm_eta_matrix_try(SEXP KSEXP, SEXP JSEXP, SEXP QSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< unsigned int >::type K(KSEXP);
    Rcpp::traits::input_parameter< unsigned int >::type J(JSEXP);
    Rcpp::traits::input_parameter< const arma::mat& >::type Q(QSEXP);
    rcpp_result_gen = Rcpp::wrap(eta_matrix(K, J, Q));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _simcdm_eta_matrix(SEXP KSEXP, SEXP JSEXP, SEXP QSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_simcdm_eta_matrix_try(KSEXP, JSEXP, QSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}

// validate (ensure exported C++ functions exist before calling them)
static int _simcdm_RcppExport_validate(const char* sig) { 
    static std::set<std::string> signatures;
    if (signatures.empty()) {
        signatures.insert("arma::mat(*sim_dina_class)(unsigned int,unsigned int,const arma::vec&,const arma::mat&,const arma::vec&,const arma::vec&)");
        signatures.insert("arma::mat(*sim_dina_attributes)(const arma::mat&,const arma::mat&)");
        signatures.insert("arma::mat(*sim_dina)(const arma::mat&,const arma::mat&,const arma::vec&,const arma::vec&)");
        signatures.insert("arma::mat(*sim_rrum_main)(const arma::mat&,const arma::mat&,const arma::vec&,const arma::mat&)");
        signatures.insert("arma::mat(*sim_rrum)(const arma::mat&,const arma::mat&,const arma::vec&,const arma::mat&)");
        signatures.insert("arma::vec(*bijectionvector)(unsigned int)");
        signatures.insert("arma::vec(*inv_bijectionvector)(unsigned int,double)");
        signatures.insert("arma::mat(*sim_q_matrix)(unsigned int,unsigned int)");
        signatures.insert("arma::mat(*eta_matrix)(unsigned int,unsigned int,const arma::mat&)");
    }
    return signatures.find(sig) != signatures.end();
}

// registerCCallable (register entry points for exported C++ functions)
RcppExport SEXP _simcdm_RcppExport_registerCCallable() { 
    R_RegisterCCallable("simcdm", "_simcdm_sim_dina_class", (DL_FUNC)_simcdm_sim_dina_class_try);
    R_RegisterCCallable("simcdm", "_simcdm_sim_dina_attributes", (DL_FUNC)_simcdm_sim_dina_attributes_try);
    R_RegisterCCallable("simcdm", "_simcdm_sim_dina", (DL_FUNC)_simcdm_sim_dina_try);
    R_RegisterCCallable("simcdm", "_simcdm_sim_rrum_main", (DL_FUNC)_simcdm_sim_rrum_main_try);
    R_RegisterCCallable("simcdm", "_simcdm_sim_rrum", (DL_FUNC)_simcdm_sim_rrum_try);
    R_RegisterCCallable("simcdm", "_simcdm_bijectionvector", (DL_FUNC)_simcdm_bijectionvector_try);
    R_RegisterCCallable("simcdm", "_simcdm_inv_bijectionvector", (DL_FUNC)_simcdm_inv_bijectionvector_try);
    R_RegisterCCallable("simcdm", "_simcdm_sim_q_matrix", (DL_FUNC)_simcdm_sim_q_matrix_try);
    R_RegisterCCallable("simcdm", "_simcdm_eta_matrix", (DL_FUNC)_simcdm_eta_matrix_try);
    R_RegisterCCallable("simcdm", "_simcdm_RcppExport_validate", (DL_FUNC)_simcdm_RcppExport_validate);
    return R_NilValue;
}

static const R_CallMethodDef CallEntries[] = {
    {"_simcdm_sim_dina_class", (DL_FUNC) &_simcdm_sim_dina_class, 6},
    {"_simcdm_sim_dina_attributes", (DL_FUNC) &_simcdm_sim_dina_attributes, 2},
    {"_simcdm_sim_dina", (DL_FUNC) &_simcdm_sim_dina, 4},
    {"_simcdm_sim_rrum_main", (DL_FUNC) &_simcdm_sim_rrum_main, 4},
    {"_simcdm_sim_rrum", (DL_FUNC) &_simcdm_sim_rrum, 4},
    {"_simcdm_bijectionvector", (DL_FUNC) &_simcdm_bijectionvector, 1},
    {"_simcdm_inv_bijectionvector", (DL_FUNC) &_simcdm_inv_bijectionvector, 2},
    {"_simcdm_sim_q_matrix", (DL_FUNC) &_simcdm_sim_q_matrix, 2},
    {"_simcdm_eta_matrix", (DL_FUNC) &_simcdm_eta_matrix, 3},
    {"_simcdm_RcppExport_registerCCallable", (DL_FUNC) &_simcdm_RcppExport_registerCCallable, 0},
    {NULL, NULL, 0}
};

RcppExport void R_init_simcdm(DllInfo *dll) {
    R_registerRoutines(dll, NULL, CallEntries, NULL, NULL);
    R_useDynamicSymbols(dll, FALSE);
}
